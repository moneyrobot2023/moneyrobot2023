# Часто задаваемые вопросы

## Указатель вопросов

### Общие сведения

* [Являются ли MimeKit и MailKit полностью бесплатными? Могу ли я использовать их в своих фирменных продуктах?](#полностью бесплатно)
* [Почему я получаю `NotSupportedException: данные недоступны для кодирования #######. Информацию об определении пользовательской кодировки смотрите в документации по кодировке.Метод RegisterProvider.`?](#register-provider)
* [Почему я получаю `"MailKit.Security.SSLHandshakeException: Произошла ошибка при попытке установить SSL или TLS-соединение."` когда я пытаюсь подключиться?](#ssl-handshake-exception)
* [Как я могу получить журнал протоколов для IMAP, POP3 или SMTP, чтобы узнать, что происходит не так?](#протокол-журнал)
* [Почему MailKit не находит некоторые из моих сообщений GMail POP3 или IMAP?](#gmail-скрытые сообщения)
* [Как я могу получить доступ к GMail с помощью MailKit?](#gmail-доступ)
* [Как я могу войти в учетную запись GMail с помощью OAuth 2.0?](#gmail-oauth2)

### Сообщения

* [Как я могу создать сообщение с вложениями?](#создать-вложения)
* [Как я могу получить основную часть сообщения?](#тело сообщения)
* [Как я могу определить, есть ли в сообщении вложения?](#имеет-вложения)
* [Почему класс `MimeMessage` не реализует `ISerializable`, чтобы я мог сериализовать сообщение на диск и прочитать его позже?](#serialize-message)
* [Как я могу анализировать сообщения?](#загрузить-сообщения)
* [Как я могу сохранить сообщения?](#сохранить-сообщения)
* [Как я могу сохранить вложения?](#сохранить-вложения)
* [Как я могу получить адреса электронной почты в заголовках From, To и Cc?](#адреса-заголовки)
* [Почему вложения с именами файлов в юникоде отображаются как "ATT0####.dat" в Outlook?](#без названия-вложения)
* [Как я могу расшифровать сообщения PGP, которые встроены в основной текст сообщения?](#decyrpt-inline-pgp)
* [Как я могу ответить на сообщение?](#reply-сообщение)
* [Как я могу переслать сообщение?](#forward-сообщение)
* [Почему текст отображается искаженным в моем приложении ASP.NET Core / .NET Core / .NET 5?](#искаженный текст)

### IMAPClient

* [Как я могу узнать количество непрочитанных сообщений в папке?](#imap-количество непрочитанных сообщений)
* [Как я могу выполнить поиск сообщений, доставленных между двумя датами?](#imap-поиск-диапазон дат)
* [Что означает "IMAPClient в данный момент занят обработкой команды."?](#imap-клиент-занят)
* [Почему я получаю исключение InvalidOperationException: "Папка в данный момент не открыта."?](#imap-папка-не-открыта-исключение)
* [Почему IMAPFolder.moveTo() не перемещает сообщение из исходной папки?](#imap-move-не перемещает)
* [Как я могу пометить сообщения как прочитанные с помощью IMAP?](#imap-пометить как прочитанный)
* [Как я могу повторно синхронизировать кэш для папки IMAP?](#imap-folder-resync)

### SmtpClient

* [Почему сообщение не отображается в папке "Отправленная почта" после его отправки?](#smtp-sent-folder)
* [Как я могу отправить электронное письмо в указанный каталог Pickupdirectory?](#smtp-указанный-каталог получения)
* [Как я могу запросить уведомление, когда сообщение прочитано пользователем?](#smtp-запрос-чтение-квитанции)
* [Как я могу обработать уведомление о получении на чтение?](#smtp-process-read-receivation)

## Общие сведения

### <a id="полностью бесплатно">Вопрос: Являются ли MimeKit и MailKit полностью бесплатными? Могу ли я использовать их в своих собственных продуктах?</a>

Да. MimeKit и MailKit являются полностью бесплатными и с открытым исходным кодом. На них распространяется лицензия
[MIT](https://opensource.org/licenses/MIT).

### <a name="register-provider">Вопрос: Почему я получаю исключение `NotSupportedException: Данные недоступны для кодирования #######. Информацию об определении пользовательской кодировки смотрите в документации по кодировке.Метод RegisterProvider.`?</a>

В .NET Core Microsoft решила выделить текстовые кодировки, отличные от Unicode, в отдельный пакет NuGet под названием
[System.Text.Encoding.CodePages](https://www.nuget.org/packages/System.Text.Encoding.Кодовые страницы).

MimeKit уже извлекает ссылку на этот пакет NuGet, поэтому вам не нужно добавлять ссылку на него в
свой проект. Тем не менее, вам все равно нужно будет зарегистрировать поставщика кодировки. Рекомендуется добавить
следующую строку кода для инициализации вашей программы (например, начало метода Main() вашей программы):

``csharp
System.Text.Encoding.RegisterProvider (System.Text.CodePagesEncodingProvider.Экземпляр);
```

### <a id="ssl-handshake-exception">Вопрос: Почему я получаю `"MailKit.Security.SSLHandshakeException: Произошла ошибка при попытке установить соединение SSL или TLS."` когда я пытаюсь подключиться?</a>

Когда вы получаете исключение с этим сообщением об ошибке, это обычно означает, что вы сталкиваетесь
с одним из следующих сценариев:

#### 1. Почтовый сервер не поддерживает SSL на указанном порту.

Существует 2 различных способа использования шифрования SSL/TLS на почтовых серверах.

Первый способ - включить шифрование SSL/TLS сразу после подключения к серверу
SMTP, POP3 или IMAP. Для этого метода требуется "порт SSL", поскольку стандартный
порт, определенный для протокола, предназначен для обмена открытым текстом.

Второй способ - с помощью команды "STARTTLS" (она же "STLS" для POP3), которая *необязательно*
поддерживается сервером.

Ниже приведена таблица протоколов, поддерживаемых MailKit, и стандартных текстовых портов
(которые либо вообще не поддерживают шифрование SSL/TLS, либо только через `STARTTLS`
расширение команды) и SSL-порты, для которых требуется шифрование SSL/TLS сразу после
успешного подключения к удаленному хосту.

|Протокол|Стандартный порт|SSL-порт|
|:------:|:-----------:|:------:|
| SMTP | 25 или 587 | 465 |
| POP3 | 110 | 995 |
| IMAP | 143 | 993 |

Важно использовать правильные "SecureSocketOptions" для порта, к которому вы подключаетесь.

Если вы подключаетесь к одному из стандартных портов, указанных выше, вам нужно будет использовать `SecureSocketOptions.Нет",
"SecureSocketOptions.StartTls` или `SecureSocketOptions.StartTlsWhenAvailable`.

Если вы подключаетесь к одному из портов SSL, вам нужно будет использовать `SecureSocketOptions.SslOnConnect`.

Вы также можете попробовать использовать `SecureSocketOptions.Автоматически`, который работает путем выбора соответствующей опции для использования
путем сравнения указанного порта с портами в приведенной выше таблице.

#### 2. Почтовый сервер, к которому вы подключаетесь, использует просроченный (или иным образом ненадежный) SSL-сертификат.

Часто почтовые серверы используют самозаверяющие сертификаты вместо сертификата,
подписанного доверенным центром сертификации. Еще одна потенциальная проблема заключается в том, что локально
установленное антивирусное программное обеспечение заменяет сертификат для проверки веб-трафика на наличие вирусов.

Если вашей системе не удается проверить сертификат почтового сервера, поскольку он не подписан
известным и доверенным центром сертификации, возникнет вышеуказанная ошибка.

Если вы работаете в системе Linux или запускаете веб-службу в контейнере Linux, возможно, можно использовать следующую команду для установки
стандартного набора корневых сертификатов Центра сертификации, используя следующую команду:

``
apt update && apt install -y ca-сертификаты
```

Другой вариант - обойти эту проблему, предоставив пользовательский [RemoteCertificateValidationCallback](https://msdn.microsoft.com/en-us/library/ms145054)
и установив его на сервере клиента. [ServerCertificateValidationCallback](http://mimekit.net/docs/html/P_MailKit_MailService_ServerCertificateValidationCallback.htm)
собственность.

В простейшем примере вы могли бы сделать что-то вроде этого (хотя я бы настоятельно не рекомендовал этого делать при
производственном использовании):

``csharp
using (var client = new SmtpClient ()) {
    клиент.ServerCertificateValidationCallback = (s,c,h,e) => true;

    клиент.Подключиться (имя хоста, порт, параметры SecureSocket.Автоматически);

    // ...
}
```

Лучшим решением может быть сравнение общего имени сертификата, эмитента, серийного номера и отпечатка
пальца с известными значениями, чтобы убедиться, что сертификату можно доверять. Возьмем следующий фрагмент кода в качестве
примера того, как это сделать:

``csharp
bool MyServerCertificateValidationCallback (отправитель объекта, сертификат X509Certificate, цепочка X509Chain, sslPolicyErrors sslPolicyErrors)
{
    if (sslPolicyErrors == sslPolicyErrors.None)
        возвращает true;

    // Примечание: Следующий код приводит к X509Certificate2, потому что проще получить значения
// для сравнения, но их также можно получить из X509Certificate.
    if (сертификат - X509Certificate2 certificate2) {
        var cn = certificate2.GetNameInfo (X509NameType.SimpleName, false);
        var fingerprint = certificate2.Отпечаток большого пальца;
        var serial = сертификат 2.Серийный номер;
        var issuer = сертификат 2.Эмитент;

        вернуть cn == "imap.gmail.com" && эмитент == "CN=GTS CA 1O1, O=Google Trust Services, C=US" &&
            серийный номер == "00A15434C2695FB1880300000000CBF786" &&
отпечаток пальца == "F351BCB631771F19AF41DFF22EB0A0839092DA51";
    }

    возвращает значение false;
}
```

Недостатком приведенного выше примера является то, что он требует жесткого кодирования известных значений для сертификатов "доверенных" почтовых серверов
, с которыми может быстро стать неудобно работать, если ваша программа предназначена для использования с
широким спектром почтовых серверов.

Наилучшим подходом было бы запросить у пользователя диалоговое окно, объясняющее, что сертификат
не является доверенным по причинам, перечисленным в
[SslPolicyErrors](https://docs.microsoft.com/en-us/dotnet/api/system.net.security.sslpolicyerrors?view=netframework-4.8)
аргумент, а также, возможно, ошибки, указанные в
[X509Chain](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509chain?view=netframework-4.8).
Если пользователь желает принять риски, связанные с доверием сертификату, ваша программа может затем "вернуть значение true`.

Для получения более подробной информации о написании пользовательского обратного вызова проверки SSL-сертификата, возможно, стоит ознакомиться с
[SslCertificateValidation.cs](https://github.com/jstedfast/MailKit/blob/master/Documentation/Examples/SslCertificateValidation.cs)
пример.

#### 3. Сервер CRL Центра сертификации для одного или нескольких сертификатов в цепочке временно недоступен.

Большинство центров сертификации, вероятно, довольно хорошо справляются с поддержанием работоспособности своих CRL-серверов и / или OCSP в режиме 24/7, но иногда


<!---
moneyrobot2023/moneyrobot2023 is a ✨ special ✨ repository because its `README.md` (this file) appears on your GitHub profile.
You can click the Preview link to take a look at your changes.
--->
